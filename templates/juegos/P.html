{% extends "base.html" %}

{% block title %}Letra P - Memoria{% endblock %}

{% block content %}
<div class="game-header">
    <h1 class="game-title">üß† Letra P - Juego de Memoria</h1>
    <p class="game-description">¬°Encuentra los pares de la letra P!</p>
    <a href="{{ url_for('index') }}" class="back-button">üè† Volver al Men√∫</a>
</div>

<div class="game-canvas-container">
    <canvas id="gameCanvas" width="800" height="600"></canvas>
</div>
{% endblock %}

{% block extra_js %}
<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

// Ajustar canvas a dispositivo m√≥vil
function resizeCanvas() {
    const container = canvas.parentElement;
    const maxWidth = Math.min(800, container.clientWidth - 40);
    const scale = maxWidth / 800;
    canvas.style.width = maxWidth + 'px';
    canvas.style.height = (600 * scale) + 'px';
}
resizeCanvas();
window.addEventListener('resize', resizeCanvas);

// Cargar im√°genes
const pMayusculaImg = new Image();
const pMinusculaImg = new Image();
const pezImg = new Image();

pMayusculaImg.src = '/assets/img/p_mayuscula.png';
pMinusculaImg.src = '/assets/img/p_minuscula.png';
pezImg.src = '/assets/img/pez_p.jpg';

// Variables del juego
let cards = [];
let flippedCards = [];
let matchedPairs = 0;
let canFlip = true;
let celebrating = false;
let celebrationTimer = 0;

// Crear las cartas (3 pares = 6 cartas)
function initializeCards() {
    const cardTypes = [
        { type: 'mayuscula', img: pMayusculaImg },
        { type: 'mayuscula', img: pMayusculaImg },
        { type: 'minuscula', img: pMinusculaImg },
        { type: 'minuscula', img: pMinusculaImg },
        { type: 'pez', img: pezImg },
        { type: 'pez', img: pezImg }
    ];
    
    // Mezclar las cartas
    for (let i = cardTypes.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [cardTypes[i], cardTypes[j]] = [cardTypes[j], cardTypes[i]];
    }
    
    // Crear objetos de cartas con posiciones
    cards = [];
    const cardWidth = 120;
    const cardHeight = 160;
    const spacing = 20;
    const startX = (canvas.width - (3 * cardWidth + 2 * spacing)) / 2;
    const startY = 180;
    
    for (let i = 0; i < 6; i++) {
        const row = Math.floor(i / 3);
        const col = i % 3;
        
        cards.push({
            type: cardTypes[i].type,
            img: cardTypes[i].img,
            x: startX + col * (cardWidth + spacing),
            y: startY + row * (cardHeight + spacing),
            width: cardWidth,
            height: cardHeight,
            flipped: false,
            matched: false,
            flipProgress: 0, // 0 = dorso, 1 = frente
            targetFlip: 0
        });
    }
}

// Funci√≥n para obtener posici√≥n del input
function getInputPosition(e, canvas) {
    const rect = canvas.getBoundingClientRect();
    const scaleX = canvas.width / rect.width;
    const scaleY = canvas.height / rect.height;
    
    let clientX, clientY;
    if (e.touches && e.touches.length > 0) {
        clientX = e.touches[0].clientX;
        clientY = e.touches[0].clientY;
    } else {
        clientX = e.clientX;
        clientY = e.clientY;
    }
    
    return {
        x: (clientX - rect.left) * scaleX,
        y: (clientY - rect.top) * scaleY
    };
}

// Dibujar carta
function drawCard(card) {
    // Animar el volteo
    const targetFlip = (card.flipped || card.matched) ? 1 : 0;
    if (card.flipProgress < targetFlip) {
        card.flipProgress = Math.min(1, card.flipProgress + 0.15);
    } else if (card.flipProgress > targetFlip) {
        card.flipProgress = Math.max(0, card.flipProgress - 0.15);
    }
    
    // Calcular escala horizontal para efecto 3D
    const scale = Math.abs(Math.cos(card.flipProgress * Math.PI));
    const cardWidth = card.width * scale;
    const offsetX = (card.width - cardWidth) / 2;
    
    // Sombra
    ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
    ctx.fillRect(card.x + 5, card.y + 5, card.width, card.height);
    
    // Determinar qu√© lado mostrar
    const showFront = card.flipProgress > 0.5;
    
    if (showFront) {
        // Mostrar imagen (frente)
        ctx.fillStyle = '#FFFFFF';
        ctx.fillRect(card.x + offsetX, card.y, cardWidth, card.height);
        
        // Borde
        ctx.strokeStyle = card.matched ? '#4CAF50' : '#667eea';
        ctx.lineWidth = 4;
        ctx.strokeRect(card.x + offsetX, card.y, cardWidth, card.height);
        
        // Dibujar imagen si est√° cargada
        if (card.img.complete && cardWidth > 10) {
            ctx.drawImage(card.img, 
                card.x + offsetX + 10, 
                card.y + 10, 
                cardWidth - 20, 
                card.height - 20);
        }
        
        // Borde verde brillante si est√° emparejada
        if (card.matched) {
            // Borde verde exterior
            ctx.strokeStyle = '#4CAF50';
            ctx.lineWidth = 8;
            ctx.strokeRect(card.x + offsetX - 4, card.y - 4, cardWidth + 8, card.height + 8);
            
            // Brillo dorado
            ctx.strokeStyle = '#FFD700';
            ctx.lineWidth = 4;
            ctx.strokeRect(card.x + offsetX - 2, card.y - 2, cardWidth + 4, card.height + 4);
        }
    } else {
        // Carta volteada (dorso)
        const gradient = ctx.createLinearGradient(
            card.x + offsetX, card.y, 
            card.x + offsetX + cardWidth, card.y + card.height
        );
        gradient.addColorStop(0, '#667eea');
        gradient.addColorStop(1, '#764ba2');
        ctx.fillStyle = gradient;
        ctx.fillRect(card.x + offsetX, card.y, cardWidth, card.height);
        
        // Borde
        ctx.strokeStyle = '#FFFFFF';
        ctx.lineWidth = 4;
        ctx.strokeRect(card.x + offsetX, card.y, cardWidth, card.height);
        
        // Letra P en el dorso (solo si la carta es visible)
        if (cardWidth > 20) {
            ctx.font = `bold ${80 * scale}px Arial`;
            ctx.fillStyle = '#FFFFFF';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('P', card.x + offsetX + cardWidth / 2, card.y + card.height / 2);
            
            // Patr√≥n decorativo
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 2;
            for (let i = 0; i < 3; i++) {
                const padding = 10 + i * 5;
                if (cardWidth > padding * 2) {
                    ctx.strokeRect(
                        card.x + offsetX + padding, 
                        card.y + padding, 
                        cardWidth - padding * 2, 
                        card.height - padding * 2
                    );
                }
            }
        }
    }
}

// Manejar clic en carta
function handleCardClick(e) {
    e.preventDefault();
    
    if (!canFlip || celebrating) return;
    
    const pos = getInputPosition(e, canvas);
    
    // Verificar qu√© carta se toc√≥
    for (let card of cards) {
        if (pos.x >= card.x && pos.x <= card.x + card.width &&
            pos.y >= card.y && pos.y <= card.y + card.height) {
            
            // No hacer nada si ya est√° volteada o emparejada
            if (card.flipped || card.matched) return;
            
            // Voltear la carta
            card.flipped = true;
            flippedCards.push(card);
            
            // Si hay 2 cartas volteadas, verificar si coinciden
            if (flippedCards.length === 2) {
                canFlip = false;
                
                setTimeout(() => {
                    const [card1, card2] = flippedCards;
                    
                    if (card1.type === card2.type) {
                        // ¬°Par encontrado!
                        card1.matched = true;
                        card2.matched = true;
                        matchedPairs++;
                        
                        // Verificar si gan√≥
                        if (matchedPairs === 3) {
                            celebrating = true;
                            celebrationTimer = 0;
                        }
                    } else {
                        // No coinciden, voltear de nuevo
                        card1.flipped = false;
                        card2.flipped = false;
                    }
                    
                    flippedCards = [];
                    canFlip = true;
                }, 1000);
            }
            
            break;
        }
    }
}

canvas.addEventListener('click', handleCardClick);
canvas.addEventListener('touchstart', handleCardClick);

// Inicializar juego
initializeCards();

// Loop del juego
function gameLoop() {
    // Fondo
    const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
    gradient.addColorStop(0, '#f093fb');
    gradient.addColorStop(1, '#f5576c');
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // T√≠tulo
    ctx.font = 'bold 40px Arial';
    ctx.fillStyle = '#FFFFFF';
    ctx.strokeStyle = '#000000';
    ctx.lineWidth = 4;
    ctx.textAlign = 'center';
    ctx.strokeText('üß† Juego de Memoria - Letra P', canvas.width / 2, 60);
    ctx.fillText('üß† Juego de Memoria - Letra P', canvas.width / 2, 60);
    
    // Contador de pares
    ctx.font = 'bold 24px Arial';
    ctx.fillStyle = '#FFFFFF';
    ctx.strokeStyle = '#000000';
    ctx.lineWidth = 3;
    ctx.strokeText(`Pares encontrados: ${matchedPairs}/3`, canvas.width / 2, 120);
    ctx.fillText(`Pares encontrados: ${matchedPairs}/3`, canvas.width / 2, 120);
    
    // Dibujar todas las cartas
    cards.forEach(card => drawCard(card));
    
    // Celebraci√≥n
    if (celebrating) {
        celebrationTimer++;
        
        ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        ctx.font = 'bold 80px Arial';
        ctx.fillStyle = '#FFD700';
        ctx.strokeStyle = 'white';
        ctx.lineWidth = 8;
        ctx.textAlign = 'center';
        ctx.strokeText('¬°GANASTE!', canvas.width / 2, canvas.height / 2 - 40);
        ctx.fillText('¬°GANASTE!', canvas.width / 2, canvas.height / 2 - 40);
        
        ctx.font = 'bold 30px Arial';
        ctx.fillStyle = '#FFFFFF';
        ctx.strokeStyle = '#000000';
        ctx.lineWidth = 4;
        ctx.strokeText('¬°Encontraste todos los pares!', canvas.width / 2, canvas.height / 2 + 20);
        ctx.fillText('¬°Encontraste todos los pares!', canvas.width / 2, canvas.height / 2 + 20);
        
        // Confeti
        for (let i = 0; i < 30; i++) {
            const x = (i * 137.5 + celebrationTimer * 2) % canvas.width;
            const y = (i * 73.2 + celebrationTimer * 3) % canvas.height;
            const size = 5 + (i % 3) * 3;
            const colors = ['#FFD700', '#FF6347', '#4CAF50', '#2196F3', '#FF69B4'];
            ctx.fillStyle = colors[i % colors.length];
            ctx.fillRect(x, y, size, size);
        }
        
        // Reiniciar despu√©s de 4 segundos
        if (celebrationTimer > 240) {
            celebrating = false;
            celebrationTimer = 0;
            matchedPairs = 0;
            flippedCards = [];
            canFlip = true;
            initializeCards();
        }
    }
    
    requestAnimationFrame(gameLoop);
}

gameLoop();
</script>
{% endblock %}
