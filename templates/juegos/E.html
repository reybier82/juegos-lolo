{% extends "base.html" %}

{% block title %}Letra E - La Ducha del Elefante{% endblock %}

{% block content %}
<div class="game-header">
    <h1 class="game-title">üêò Letra E - La Ducha del Elefante</h1>
    <p class="game-description">¬°Arrastra la nube E para darle una ducha al elefante!</p>
    <a href="{{ url_for('index') }}" class="back-button">üè† Volver al Men√∫</a>
</div>

<div class="game-canvas-container">
    <canvas id="gameCanvas" width="800" height="600"></canvas>
</div>
{% endblock %}

{% block extra_js %}
<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

// Ajustar canvas a dispositivo m√≥vil
function resizeCanvas() {
    const container = canvas.parentElement;
    const maxWidth = Math.min(800, container.clientWidth - 40);
    const scale = maxWidth / 800;
    canvas.style.width = maxWidth + 'px';
    canvas.style.height = (600 * scale) + 'px';
}
resizeCanvas();
window.addEventListener('resize', resizeCanvas);

// Variables del juego
let score = 0;
let elephantHappy = false;
let isRaining = false;
let rainDrops = [];
let cloudDragging = false;
let cloudX = 400;
let cloudY = 100;
let elephantX = 400;
let elephantY = 400;

// Cargar im√°genes del elefante
const elephantSadImg = new Image();
const elephantHappyImg = new Image();
let elephantSadProcessed = null;
let elephantHappyProcessed = null;
let imagesLoaded = 0;

elephantSadImg.src = "/assets/img/elefante_triste.jpeg";
elephantHappyImg.src = "/assets/img/elefante_feliz.jpeg";

// Funci√≥n para procesar imagen y quitar fondo blanco y texto
function processImage(img) {
    const tempCanvas = document.createElement('canvas');
    const tempCtx = tempCanvas.getContext('2d');
    tempCanvas.width = img.width;
    tempCanvas.height = img.height;
    
    tempCtx.drawImage(img, 0, 0);
    
    const imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
    const data = imageData.data;
    const width = tempCanvas.width;
    const height = tempCanvas.height;
    
    // Hacer transparente el fondo blanco y texto
    for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
            const i = (y * width + x) * 4;
            const r = data[i];
            const g = data[i + 1];
            const b = data[i + 2];
            
            // Eliminar toda la parte inferior (√∫ltimos 15% de la imagen) donde est√° el texto
            if (y > height * 0.85) {
                data[i + 3] = 0;
                continue;
            }
            
            // Si el pixel es blanco o casi blanco, hacerlo transparente
            if (r > 220 && g > 220 && b > 220) {
                data[i + 3] = 0;
            }
            
            // Tambi√©n eliminar p√≠xeles grises (texto/marcas de agua)
            else if (r > 180 && g > 180 && b > 180 && Math.abs(r - g) < 30 && Math.abs(r - b) < 30) {
                data[i + 3] = 0;
            }
            
            // Eliminar p√≠xeles oscuros que sean texto (gris oscuro/negro sobre fondo claro)
            else if (r < 100 && g < 100 && b < 100) {
                // Verificar si est√° rodeado de p√≠xeles claros (es texto)
                let nearbyBright = 0;
                for (let dy = -2; dy <= 2; dy++) {
                    for (let dx = -2; dx <= 2; dx++) {
                        const ny = y + dy;
                        const nx = x + dx;
                        if (ny >= 0 && ny < height && nx >= 0 && nx < width) {
                            const ni = (ny * width + nx) * 4;
                            if (data[ni] > 200 && data[ni + 1] > 200 && data[ni + 2] > 200) {
                                nearbyBright++;
                            }
                        }
                    }
                }
                // Si est√° rodeado de p√≠xeles claros, es texto
                if (nearbyBright > 10) {
                    data[i + 3] = 0;
                }
            }
        }
    }
    
    tempCtx.putImageData(imageData, 0, 0);
    return tempCanvas;
}

elephantSadImg.onload = () => {
    elephantSadProcessed = processImage(elephantSadImg);
    imagesLoaded++;
    if (imagesLoaded === 2) startGame();
};

elephantHappyImg.onload = () => {
    elephantHappyProcessed = processImage(elephantHappyImg);
    imagesLoaded++;
    if (imagesLoaded === 2) startGame();
};

// Clase para las gotas de lluvia (m√°s grandes)
class RainDrop {
    constructor(x) {
        this.x = x + (Math.random() - 0.5) * 100;
        this.y = cloudY + 60;
        this.speed = 4 + Math.random() * 3;
        this.length = 20 + Math.random() * 15; // Gotas m√°s largas
        this.width = 3 + Math.random() * 2; // Gotas m√°s gruesas
    }
    
    update() {
        this.y += this.speed;
    }
    
    draw() {
        ctx.strokeStyle = '#4FC3F7';
        ctx.lineWidth = this.width;
        ctx.lineCap = 'round';
        ctx.beginPath();
        ctx.moveTo(this.x, this.y);
        ctx.lineTo(this.x, this.y + this.length);
        ctx.stroke();
    }
    
    isOffScreen() {
        return this.y > canvas.height;
    }
}

// Dibujar el elefante
function drawElephant() {
    const centerX = elephantX;
    const centerY = elephantY;
    
    // Seleccionar la imagen procesada seg√∫n el estado del elefante
    const elephantCanvas = elephantHappy ? elephantHappyProcessed : elephantSadProcessed;
    
    if (!elephantCanvas) return; // Si a√∫n no est√° procesada, no dibujar
    
    // Tama√±o de la imagen
    const imgWidth = 300;
    const imgHeight = 300;
    
    // Dibujar la imagen procesada (sin fondo blanco)
    ctx.drawImage(
        elephantCanvas,
        centerX - imgWidth / 2,
        centerY - imgHeight / 2,
        imgWidth,
        imgHeight
    );
    
    // Si el elefante est√° triste (sucio), dibujar manchas
    if (!elephantHappy) {
        ctx.fillStyle = 'rgba(80, 60, 40, 0.6)'; // Color marr√≥n oscuro semi-transparente
        
        // Mancha 1 - en el cuerpo
        ctx.beginPath();
        ctx.ellipse(centerX - 30, centerY - 20, 25, 20, 0.3, 0, Math.PI * 2);
        ctx.fill();
        
        // Mancha 2 - en la cabeza
        ctx.beginPath();
        ctx.ellipse(centerX + 20, centerY - 60, 20, 15, -0.2, 0, Math.PI * 2);
        ctx.fill();
        
        // Mancha 3 - en el costado
        ctx.beginPath();
        ctx.ellipse(centerX + 40, centerY + 10, 18, 22, 0.5, 0, Math.PI * 2);
        ctx.fill();
        
        // Mancha 4 - peque√±a en la oreja
        ctx.beginPath();
        ctx.ellipse(centerX - 50, centerY - 50, 12, 10, 0, 0, Math.PI * 2);
        ctx.fill();
        
        // Mancha 5 - en la pata
        ctx.beginPath();
        ctx.ellipse(centerX - 20, centerY + 60, 15, 12, 0, 0, Math.PI * 2);
        ctx.fill();
    }
}

// Dibujar la nube con forma de E
function drawCloud() {
    // Sombra de la nube
    ctx.shadowColor = 'rgba(0, 0, 0, 0.2)';
    ctx.shadowBlur = 10;
    ctx.shadowOffsetX = 5;
    ctx.shadowOffsetY = 5;
    
    // Nube base
    ctx.fillStyle = cloudDragging ? '#E1F5FE' : '#FFFFFF';
    ctx.beginPath();
    ctx.arc(cloudX - 40, cloudY, 30, 0, Math.PI * 2);
    ctx.arc(cloudX - 10, cloudY - 10, 35, 0, Math.PI * 2);
    ctx.arc(cloudX + 20, cloudY, 30, 0, Math.PI * 2);
    ctx.arc(cloudX + 40, cloudY + 5, 25, 0, Math.PI * 2);
    ctx.fill();
    
    // Resetear sombra
    ctx.shadowColor = 'transparent';
    ctx.shadowBlur = 0;
    ctx.shadowOffsetX = 0;
    ctx.shadowOffsetY = 0;
    
    // Letra E en la nube
    ctx.font = 'bold 60px Arial';
    ctx.fillStyle = '#1976D2';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('E', cloudX, cloudY);
    
    // Borde de la letra E
    ctx.strokeStyle = '#0D47A1';
    ctx.lineWidth = 3;
    ctx.strokeText('E', cloudX, cloudY);
}

// Verificar si el mouse/touch est√° sobre la nube
function isOverCloud(x, y) {
    const distance = Math.sqrt((x - cloudX) ** 2 + (y - cloudY) ** 2);
    return distance < 60;
}

// Verificar si la nube est√° sobre el elefante (encima, no dentro)
function isCloudOverElephant() {
    // La nube debe estar horizontalmente cerca del elefante
    const horizontalDistance = Math.abs(cloudX - elephantX);
    
    // La nube debe estar ENCIMA del elefante (Y menor) - m√°s distancia (3 dedos = ~150px)
    const isAbove = cloudY < elephantY - 150;
    
    // La nube debe estar por debajo del cielo (no muy arriba)
    const notTooHigh = cloudY > 180;
    
    // Verificar que est√© alineada horizontalmente y encima
    return horizontalDistance < 120 && isAbove && notTooHigh;
}

// Manejo de eventos de arrastre
let dragOffsetX = 0;
let dragOffsetY = 0;

function handleStart(e) {
    e.preventDefault();
    const pos = getInputPosition(e, canvas);
    
    if (isOverCloud(pos.x, pos.y)) {
        cloudDragging = true;
        dragOffsetX = pos.x - cloudX;
        dragOffsetY = pos.y - cloudY;
    }
}

function handleMove(e) {
    e.preventDefault();
    if (cloudDragging) {
        const pos = getInputPosition(e, canvas);
        cloudX = pos.x - dragOffsetX;
        cloudY = pos.y - dragOffsetY;
        
        // Limitar la nube dentro del canvas
        cloudX = Math.max(60, Math.min(canvas.width - 60, cloudX));
        cloudY = Math.max(60, Math.min(canvas.height - 100, cloudY));
    }
}

function handleEnd(e) {
    e.preventDefault();
    if (cloudDragging) {
        cloudDragging = false;
        
        // Verificar si la nube est√° sobre el elefante
        if (isCloudOverElephant()) {
            startRain();
        }
    }
}

// Iniciar la lluvia
function startRain() {
    if (!isRaining) {
        isRaining = true;
        elephantHappy = true;
        score++;
        playSuccessSound();
        
        // Crear gotas de lluvia (m√°s cantidad)
        const rainInterval = setInterval(() => {
            if (rainDrops.length < 80) {
                rainDrops.push(new RainDrop(cloudX));
                rainDrops.push(new RainDrop(cloudX)); // Doble cantidad
            }
        }, 40);
        
        // Detener la lluvia despu√©s de 3 segundos
        setTimeout(() => {
            clearInterval(rainInterval);
            setTimeout(() => {
                isRaining = false;
                rainDrops = [];
                elephantHappy = false;
                // Mover la nube de vuelta arriba
                cloudX = 200 + Math.random() * 400;
                cloudY = 100;
            }, 2000);
        }, 3000);
        
        // Mostrar mensaje de felicitaci√≥n
        showCelebration('¬°El elefante est√° feliz! üêòüí¶');
    }
}

// Loop del juego
function gameLoop() {
    // Verificar que las im√°genes est√©n cargadas
    if (imagesLoaded < 2) {
        // Mostrar mensaje de carga
        ctx.fillStyle = '#87CEEB';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.font = 'bold 30px Arial';
        ctx.fillStyle = '#1976D2';
        ctx.textAlign = 'center';
        ctx.fillText('Cargando...', canvas.width / 2, canvas.height / 2);
        requestAnimationFrame(gameLoop);
        return;
    }
    
    // Fondo (cielo)
    const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
    gradient.addColorStop(0, '#87CEEB');
    gradient.addColorStop(1, '#E0F6FF');
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // Suelo
    ctx.fillStyle = '#8BC34A';
    ctx.fillRect(0, canvas.height - 100, canvas.width, 100);
    
    // Pasto decorativo
    ctx.fillStyle = '#689F38';
    for (let i = 0; i < canvas.width; i += 30) {
        ctx.beginPath();
        ctx.moveTo(i, canvas.height - 100);
        ctx.lineTo(i + 10, canvas.height - 110);
        ctx.lineTo(i + 20, canvas.height - 100);
        ctx.fill();
    }
    
    // Sol
    ctx.fillStyle = '#FFD54F';
    ctx.beginPath();
    ctx.arc(700, 80, 40, 0, Math.PI * 2);
    ctx.fill();
    
    // Rayos del sol
    ctx.strokeStyle = '#FFD54F';
    ctx.lineWidth = 4;
    for (let i = 0; i < 8; i++) {
        const angle = (Math.PI * 2 * i) / 8;
        ctx.beginPath();
        ctx.moveTo(700 + Math.cos(angle) * 50, 80 + Math.sin(angle) * 50);
        ctx.lineTo(700 + Math.cos(angle) * 70, 80 + Math.sin(angle) * 70);
        ctx.stroke();
    }
    
    // Dibujar elefante
    drawElephant();
    
    // Actualizar y dibujar gotas de lluvia
    if (isRaining || rainDrops.length > 0) {
        rainDrops = rainDrops.filter(drop => !drop.isOffScreen());
        rainDrops.forEach(drop => {
            drop.update();
            drop.draw();
        });
    }
    
    // Dibujar nube
    drawCloud();
    
    // Instrucciones
    if (score === 0) {
        ctx.font = 'bold 22px Arial';
        ctx.fillStyle = '#1976D2';
        ctx.strokeStyle = 'white';
        ctx.lineWidth = 5;
        ctx.textAlign = 'center';
        
        // Instrucci√≥n adicional
        ctx.font = 'bold 18px Arial';
    }
    
    // Puntuaci√≥n
    ctx.font = 'bold 30px Arial';
    ctx.fillStyle = '#FF6B6B';
    ctx.strokeStyle = 'white';
    ctx.lineWidth = 4;
    ctx.textAlign = 'left';
    ctx.strokeText(`üêò Duchas: ${score}`, 20, canvas.height - 20);
    ctx.fillText(`üêò Duchas: ${score}`, 20, canvas.height - 20);
    
    requestAnimationFrame(gameLoop);
}

// Funci√≥n para iniciar el juego cuando las im√°genes est√©n cargadas
function startGame() {
    // Event listeners
    canvas.addEventListener('mousedown', handleStart);
    canvas.addEventListener('mousemove', handleMove);
    canvas.addEventListener('mouseup', handleEnd);
    canvas.addEventListener('touchstart', handleStart);
    canvas.addEventListener('touchmove', handleMove);
    canvas.addEventListener('touchend', handleEnd);
    
    // Iniciar loop del juego
    gameLoop();
}

// Iniciar el loop (mostrar√° "Cargando..." hasta que las im√°genes est√©n listas)
gameLoop();
</script>
{% endblock %}
